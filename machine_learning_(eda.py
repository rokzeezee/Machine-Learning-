# -*- coding: utf-8 -*-
"""MACHINE_LEARNING_(EDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/rokzeezee/PandasYouTubeSeries/blob/main/MACHINE_LEARNING_(EDA.ipynb
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from imblearn.over_sampling import RandomOverSampler

df=pd.read_csv("/content/column_2C_weka.csv")

df.head()

df.isnull()

df.info()

df["class"].nunique()

df["class"].value_counts()

df["class"]=(df["class"] == "Normal" ).astype(int)

df.info()

df.shape



df.describe()

for labels in df [:-1]:
  plt.hist(df[df["class"]==1][labels], color = "blue", label = "Normal" , alpha = 0.7 ,density= True)
  plt.hist(df[df["class"]==0][labels], color = "red", label = "Abnormal" , alpha = 0.7 ,density= True)
  plt.title (labels)
  plt.xlabel (labels)
  plt.ylabel("probability")
  plt.legend()
  plt.show()

color_list = ['blue' if i =="Normal" else 'green' for i in df.loc[:,'class']]
pd.plotting.scatter_matrix(df.loc[:, df.columns != 'class'],
                                       c=color_list,
                                       figsize= [15,15],
                                       diagonal='hist',
                                       alpha=0.7,
                                       s = 200,
                                       marker = "*",
                                       edgecolor= "black")
plt.show()

sns.countplot(x="class", data=df )

df["class"].value_counts()

knn = KNeighborsClassifier(n_neighbors = 3)
x,y = df.loc[:,df.columns != 'class'], df.loc[:,'class']
knn.fit(x,y)
prediction = knn.predict(x)
print('Prediction: {}'.format(prediction))



"""# **where 0 = is Normal and 1 = Is abnormal **"""

#train test split

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.3,random_state = 1)
knn = KNeighborsClassifier(n_neighbors = 3)
x,y = df.loc[:,df.columns != 'class'], df.loc[:,'class']
knn.fit(x_train,y_train)
prediction = knn.predict(x_test)
#print('Prediction: {}'.format(prediction))
print('With KNN (K=3) accuracy is: ',knn.score(x_test,y_test)) # accuracy



"""# **Train , validation , test dataset**"""

train, valid, test =np.split(df.sample(frac=1) ,[int(0.6 *len(df)) , int(0.8 *len(df))])

"""

> Indented block

"""

def scale_dataset(dataframe , oversample=False):
    X=dataframe[dataframe.columns[:-1]].values
    Y=dataframe[dataframe.columns[-1]].values

    scaler = StandardScaler()
    X = scaler.fit_transform(X)
    if oversample:
      ros = RandomOverSampler()
      X,Y =ros.fit_resample(X,Y)


    df = np.hstack((X, np.reshape(Y, (-1 ,1))))
  
    return df , X , Y

train["class"].value_counts()

"""# where 0 is normal and 1's are **abnormal**"""



print(len(train[train["class"]==1]))
print(len(train[train["class"]==0]))

valid

test

train,X_train,Y_train =scale_dataset(train , oversample= True)

#Model complexity
neig = np.arange(1, 25)
train_accuracy = []
test_accuracy = []
# Loop over different values of k
for i, k in enumerate(neig):
    # k from 1 to 25(exclude)
    knn = KNeighborsClassifier(n_neighbors=k)
    # Fit with knn
    knn.fit(x_train,y_train)
    #train accuracy
    train_accuracy.append(knn.score(x_train, y_train))
    # test accuracy
    test_accuracy.append(knn.score(x_test, y_test))

# Plot
plt.figure(figsize=[13,8])
plt.plot(neig, test_accuracy, label = 'Testing Accuracy')
plt.plot(neig, train_accuracy, label = 'Training Accuracy')
plt.legend()
plt.title('-value VS Accuracy')
plt.xlabel('Number of Neighbors')
plt.ylabel('Accuracy')
plt.xticks(neig)
plt.savefig('graph.png')
plt.show()
print("Best accuracy is {} with K = {}".format(np.max(test_accuracy),1+test_accuracy.index(np.max(test_accuracy))))

#create data1 that includes pelvic_incidence that is feature and sacral_slope that is target variable
data1 = df[df['class'] == 1]
x = np.array(data1.loc[:,'pelvic_incidence']).reshape(-1,1)
y = np.array(data1.loc[:,'sacral_slope']).reshape(-1,1)
# Scatter
plt.figure(figsize=[10,10])
plt.scatter(x=x,y=y)
plt.xlabel('pelvic_incidence')
plt.ylabel('sacral_slope')
plt.savefig('graph2.png')
plt.show()

